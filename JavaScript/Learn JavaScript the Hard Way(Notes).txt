Parsing Engine
Lexical Environment - where something is written in the code physcially is important, that it determines certain things as far as how javascript engine will decide and interpret where things live and where things will sit inside the memory and how they will connect to each other.
Execution content



Global Object(window), Global variable (this) both are equal at the global level.

parsing engine is taking my code and taking decisions.

Program Execution Phases in Javascript:

Phase 1 : wrapper around my code - execution context - memory space -- This is Creation Phase ( allocation of memory space to variables and functions)
then execution starts in phase 2 - Code Execution - This is exection phase (assignments, printing and other )

HOISITNG:
variables setup (and set equal to undefined) and functions setup

b();
console.log(a);

var a = "Hello World";
function b(){
	console.log("I'm b");
}

o/p:

I'm b. funtions will be invoked doesnt matter where its position is in the program (above or below of invoking call)
undefined. but its not the case for variables, in the first phase memory is created for variables and they are set equal to undefined before they are declared.
		Since a is being printed here before it is declared, undefined special value will be printed to console.

Javascript and undefined

undefned is a special value and the special keyword that javascrit has in it internally that means the variables hasn't been set

This is why we see what we see and why javascript behaves does what it does

Single threaded : One command being executed at a time

Javascript behaves in a single threaded manner for us as a programmer but not may be underhood of the browser

Synchronous Execution: One at a time not two or three at a time

code is executed one line at a time.

Function Invoction and Execution Stack:

Invocation - means running a function, in javascript we use () to invoke a funtion

each function will create a new execution context on the top of the parent execution context in the form of stack , this Execution stack is formed. (last in First Out)

FUNCTIONS , CONTEXT and VARIABLE ENVIRONMENT

variable environment : is where the variables created and how they are related to each other in memory.

Every execution context has its own variable environment

Example prog:

function b(){
	var myvar;
	console.log(myvar);//b execution context which has new memory for myvar
}
function a(){
	var myvar = 2;
	console.log(myvar);//a execution context which has new memory for myvar
	b();
}

var myvar = 1;
console.log(myvar);//global
a();
console.log(myvar);//global

o/p:
1
2
undefined
1

THE SCOPE CHAIN:

Every Execution context will have a reference to its outer environment which is GLobal Environment. 

Program:
function b(){ // this function b() is physically sitting where var myvar = 1  is sitting , in a javascript file but not in any function. so its physcal or lexial environment reference is to global.
	
	console.log(myvar);//b execution context where myvar is empty since its not declared(no memory)
}
function a(){
	var myvar = 2;
	b();
}

var myvar = 1; //global
a();

o/p:
1 //not undefined

--- so when you ask for a variable while running a line of code inside any particular execution content if it can't find that variable in that context then it will look into the outer reference for the value of that variable and prints it. (here it is javascript engine)..
--- the outer references depends on where that particular execution context sits lexically. 
--- Here b() sits not inside a but the global level, so its outer lexical environment is global and so as a()'s...
--- so when we asked for myvar in b() it went and looked into its outer reference (outer lexical environment) and prints its value.

* When you invoke a function the javascript engines creates an outer reference for that execution context and it looks where the code is physically sitting and then it created appropriate outer reference
based on where the function is physcially written in the javascript file. This entire act of searching, this chain of references to outer environments is called SCOPE CHAIN.

Senario 2:

function a(){
	
	function b(){ // this function b() is now physically sitting inside function a() so its outer reference is not global anywhere, it would be a().
	
	console.log(myvar);
}
	var myvar = 2;
	b();
}

var myvar = 1; //global
a();
b(); // b() is not sitting physically global level instead its in function a() so this invoking will create an error. cuz you cannot invoke a function which is sitting inside another function form outside

o/p: error b is not defined.

Senario 3:
function a(){
	
	function b(){ // this function b() is now physically sitting inside function a() so its outer reference is not global anywhere, it would be a().
	
		console.log(myvar);
	}
	var myvar = 2;
	b();
}

var myvar = 1; //global
a();

o/p : 2. // since b() is sitting in a() its outer reference will be pointing to a() so myvar is not defined in its execution context then it will look into its outer reference so it will print 1.

Senario 4:

function a(){
	
	function b(){ // this function b() is now physically sitting inside function a() so its outer reference is not global anywhere, it would be a().
	
		console.log(myvar);
	}
	//var myvar = 2; now if I remove this line what happens. 
	b();
}

var myvar = 1; //global
a();

o/p : 1 // myvar in b() will search for its value in its outer reference a(), but its not defined in a() as well so outer reference of a() is global context so it will search for the value here which is 1.


SCOPE:

Where a variable is available in your code...

Let - keyword to declare a variable (ES6 or ES 2015): ALlows javascript engine to use block scoping

if you try to use a variable which is declared using let before its declared statement, you will get an error cuz of let keyword. you are not allowed to use before its declared statement.

Asynchronous: MOre than One at a time

Javascript engine first finishes the execution stack synchronously and once the stack is empty it will look into event stack and see if there is anything in queue to execute(like click events)

Program:

function waitThreeSeconds(){
var ms = 3000 + new Date().getTime();
while(new Date < ms){}
console.log("finished function");

function clickHandler(){
console.log("click event!");
}

//listen for the click event

document.addEventListener('click', clickHandler);

waitThreeSeconds();
console.log('finished execution');

o/p: finished function
finished execution

Now when you click on the document window of browser you will get o/p as below
finished function
finished execution
click event!

DYNAMIC TYPING: (JavaScript)

You don't tell the javascript engine what type of data a variable holds, it figures it out while your code is running...

Variable can hold different types of values cuz it's all figured out during execution.

STATIC TYPING:

you tell the compiler what type of data you are actually going to work on. (java, c#)

PRIMITIVE TYPES:

there are SIX Primitive types - 

a type of data that represents a single value which is not a object ( cuz it is a collection of name value pairs)

1)UNDEFINED - undefined represents lack of existence - the code never set the value(you shouldn't set a variable to this)
2)NULL - null represents lack of existence - when the variable has no value ( you can assign this to a variable when you a variable to be set to nothing)
3)BOOLEAN - True or False
4)NUMBER - Floating point number (there's always some decimals). Unlike other programming languages there's only one number type...and it can make math weird
5)STRING - a sequence of characters. 
6)Symbol - new and used in ES6.

OPERATORS: are special types of functions(pre written code) which will return a value when parameters are passes to them.
+, -, *, /, >, < ...

OPERATOR PRECEDENCE AND ASSOCIATIVITY 

OPERATOR PRECEDENCE: mean which operator gets the call first. Functions are called in order of precedence
ASSOCIATIVITY: what order the operators gets called when they have same precedence - LEFT TO RIGHT

LOOK into precedence and associativity table in developer.mozilla.org

COERSION - Converting a value from one type to another - This happens quite often in JavaScript because its dynamically typed.
Coersed is nothing but conversion; var a = 1 + '2' => 12 -- here number 1 is coersed to string 1 and concatinated to 2 so the output. this happens only for '+' concatenation operator

COMPARISON OPERATORS:
console.log(1<2<3) -- > True . console.log(3<2<1) -- True. 3<2 i False. javascript converts False to number value which is 0 so 0<1 becomes true...
==, ====
0 == False => True but if we use 0===False => False. cuz === is strictly equal

Check the link developer.mozilla.org/en-US/docs/Web/JavaScript/Equity_comparisions_and_sameness

EXiSTENCE AND BOOLEAN

something doesnt exist will given false when we use Boolean(undefined), Boolean(null), Booleans("")

var a;

if(a){
 console.log("there is something...");
}else{
console.log("there is nothing...");
}

o/p : there is nothing... ==> anything in if will be converted to boolean value so Boolean(a)-- here a is undefined; so Boolean(undefined) returns false.
if a is null or empty still the result will be false and second statement will be printed

DEFAULT VALUES:

Default values can be set using '||' operator. 

Example: 
function greet(name){
 name = name || 'print something';
console.log('Hello ' + name);
}

greet('nishanth');
greet(); //no parameters here.
greet(0); //this will also pass nothing

0/p:
Hello nishanth
Hello print something
Hello print something

FRAMEWORK or Library :

a grouping of javascript code performing a task that is intended to be reusable...

OBJECTS AND FUNCTIONS:

var person = new Object();

person["firstname"] = "Nishanth";
person["Lastname"] = "Maraboina";

console.log(person); //prints object
console.log(person[firstname]); //prints Nishanth

you can also use . operator like below

console.log(person.firstname); //prints Nishanth ..// after dot anything will be string so you dnt have to give ""

var person.address = new Object();

person.address.city = "Hyderabad";
person.address.state = "Telangana";
person.address.country = "India";

console.log(person.address.city); // Hyderabad
console.log(person.address.state); //Telangana
console.log(person[address][country]); //India

dot representation is the recommended and best one to use for objects...

OBJECTS AND OBJECT LITERALS:
Objecct literal is '{}'

so you can create object as var person = {};

var person = {
firstname: Nishanth,
lastname: Maraboina,
address: {
city: Hyderabad,
State: Telangana,
Country: India
};

console.log(person);

o/p: object { firstname: "Nishanth", lastname: "Maraboina", address: object}
	address : object 
		city: Hyderabad
		state: Telangana
		country: India


Scenario 2:

var nishanth = {
firstname: Nishanth,
lastname: Maraboina,
address: {
city: Hyderabad,
State: Telangana,
Country: India
};

function greet(name){
console.log("Hello " + name.firstname);
}

greet(nishanth);

o/p: Hello Nishanth

you can also do greet ({firstname: "Nishanth", lastname: "Maraboina"});

you can also add new object to an existing object like below:

nishanth.address2 = {
streetname: "Telephone Colony",
area: "kothapet"
};








	






